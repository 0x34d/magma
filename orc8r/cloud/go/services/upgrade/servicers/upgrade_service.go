/*
Copyright (c) Facebook, Inc. and its affiliates.
All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree.
*/

// Upgrade service which provides functionality for managing access gateway
// versioning and rolling upgrades for networks.
//
// The upgrade service depends on the following tables:
//
// 1. channel => [version strings]
//	A global table mapping a release channel to a list of currently
//	supported package versions for that channel.
// 2. tier => TierInfo
//	A per-network table that maps a tier to its model. Tiers are a way to
//	partition a network into groups of gateways which can be targeted to
//	update to a specific version in order to implement a rolling upgrade.
//
// UpgradeService implements the UpgradeServiceServer interface defined in the
// .go file generated by upgrade_service.proto. See .proto file for interface
// documentation
package servicers

import (
	"magma/orc8r/cloud/go/datastore"
	"magma/orc8r/cloud/go/protos"
	upgrade_protos "magma/orc8r/cloud/go/services/upgrade/protos"

	"github.com/golang/glog"
	"golang.org/x/net/context"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const (
	// Global table: channel string -> supportedReleases protos.SupportedVersions
	releaseTableName = "releases"

	// NetworkID-partitioned tables: tier string -> protos.TierInfo
	TierTableName = "tierVersions"
)

type UpgradeService struct {
	store datastore.Api
}

func NewUpgradeService(store datastore.Api) *UpgradeService {
	return &UpgradeService{store: store}
}

//------------------------------------------------------------------------------
// Release management APIs
//------------------------------------------------------------------------------

func (srv *UpgradeService) CreateReleaseChannel(
	context context.Context,
	request *upgrade_protos.CreateOrUpdateReleaseChannelRequest,
) (*protos.Void, error) {
	channel := request.GetChannelName()
	ret := &protos.Void{}
	if err := upgrade_protos.ValidateCreateOrUpdateReleaseChannelReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	channelExists, err := srv.doesChannelExist(channel)
	if err != nil {
		glog.Errorf("Error while checking if channel %s exists: %s", channel, err)
		return ret, status.Errorf(codes.Aborted, "Error while creating release channel")
	}
	if channelExists {
		glog.Errorf("Create request for existing channel %s", channel)
		return ret, status.Errorf(codes.AlreadyExists, "Release channel %s already exists", channel)
	}

	marshaledProto, err := protos.MarshalIntern(request.GetChannel())
	if err != nil {
		glog.Errorf("Error while marshaling channel versions: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error while creating release channel")
	}

	err = srv.store.Put(releaseTableName, channel, marshaledProto)
	if err != nil {
		glog.Errorf("Error while persisting new release channel %s: %s", channel, err)
		return ret, status.Errorf(codes.Aborted, "Error while creating release channel")
	}
	return ret, nil
}

func (srv *UpgradeService) GetReleaseChannel(
	context context.Context,
	request *upgrade_protos.GetReleaseChannelRequest,
) (*upgrade_protos.ReleaseChannel, error) {
	ret := &upgrade_protos.ReleaseChannel{}
	if err := upgrade_protos.ValidateGetReleaseChannelRequest(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	channelName := request.GetChannelName()
	marshalledChannel, _, err := srv.store.Get(releaseTableName, channelName)
	if err != nil {
		glog.Errorf("Error while getting release channel: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error fetching release channel %s", channelName)
	}

	err = protos.Unmarshal(marshalledChannel, ret)
	if err != nil {
		glog.Errorf("Error while unmarshaling proto: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error fetching release channel %s", channelName)
	}
	return ret, nil
}

func (srv *UpgradeService) ListReleaseChannels(
	context context.Context,
	request *protos.Void,
) (*upgrade_protos.ListReleaseChannelsResponse, error) {
	ret := &upgrade_protos.ListReleaseChannelsResponse{}
	channelIds, err := srv.store.ListKeys(releaseTableName)
	if err != nil {
		glog.Errorf("Error while listing release channels: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error while listing release channels")
	}
	ret.ChannelIds = channelIds
	return ret, nil
}

func (srv *UpgradeService) UpdateReleaseChannel(
	context context.Context,
	request *upgrade_protos.CreateOrUpdateReleaseChannelRequest,
) (*protos.Void, error) {
	channelName := request.GetChannelName()
	ret := &protos.Void{}
	if err := upgrade_protos.ValidateCreateOrUpdateReleaseChannelReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	channelExists, err := srv.doesChannelExist(channelName)
	if err != nil {
		glog.Errorf("Error whiel checking if channel %s exists: %s", channelName, err)
		return ret, status.Errorf(codes.Aborted, "Error while updating release channel")
	}
	if !channelExists {
		glog.Errorf("Updating nonexistent channel %s", channelName)
		return ret, status.Errorf(codes.FailedPrecondition, "Can't update nonexistent channel")
	}

	marshaledProto, err := protos.MarshalIntern(request.GetChannel())
	if err != nil {
		glog.Errorf("Error while marshaling release channel: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error while updating release channel")
	}

	err = srv.store.Put(releaseTableName, channelName, marshaledProto)
	if err != nil {
		glog.Errorf("Error while persisting changes to release channel: %s", err)
		return ret, status.Errorf(codes.Unavailable, "Error while updating channel")
	}
	return ret, nil
}

func (srv *UpgradeService) DeleteReleaseChannel(
	context context.Context,
	request *upgrade_protos.DeleteReleaseChannelRequest,
) (*protos.Void, error) {
	channelName := request.GetChannelName()
	ret := &protos.Void{}
	if err := upgrade_protos.ValidateDeleteReleaseChannelReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	channelExists, err := srv.doesChannelExist(channelName)
	if err != nil {
		glog.Errorf("Error while checking if channel %s exists: %s", channelName, err)
		return ret, status.Errorf(codes.Aborted, "Error while deleting release channel")
	}
	if !channelExists {
		glog.Errorf("Deleting nonexistent channel %s", channelName)
		return ret, status.Errorf(codes.FailedPrecondition, "Can't delete nonexistent channel")
	}

	err = srv.store.Delete(releaseTableName, channelName)
	if err != nil {
		glog.Errorf("Error while deleting channel: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error while deleting release channel")
	}
	return ret, nil
}

func (srv *UpgradeService) doesChannelExist(channel string) (bool, error) {
	channels, err := srv.store.ListKeys(releaseTableName)
	if err != nil {
		return false, err
	}

	for _, c := range channels {
		if c == channel {
			return true, nil
		}
	}
	return false, nil
}

//------------------------------------------------------------------------------
// Tier versioning APIs
//------------------------------------------------------------------------------

func (srv *UpgradeService) GetTiers(
	context context.Context,
	request *upgrade_protos.GetTiersRequest,
) (*upgrade_protos.GetTiersResponse, error) {
	ret := &upgrade_protos.GetTiersResponse{}
	if err := upgrade_protos.ValidateGetTiersReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	networkID := request.GetNetworkId()
	tiersToQuery, err := srv.loadTiers(networkID, request.GetTierFilter())
	if err != nil {
		glog.Errorf("Error while getting tiers to query: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error while getting tiers")
	}

	tiers, err := srv.store.GetMany(getTierTableName(networkID), tiersToQuery)
	if err != nil {
		glog.Errorf("Error querying for tier versions: %s", err)
		return ret, status.Errorf(codes.Aborted, "Error while getting tiers")
	}

	retMap := make(map[string]*upgrade_protos.TierInfo, len(tiers))
	for tier, val := range tiers {
		if val.Value == nil || len(val.Value) == 0 {
			glog.Errorf("Nonexistent tier %s queried", tier)
			return ret, status.Errorf(codes.Aborted, "Tier %s does not exist", tier)
		}

		unmarshaledTier := &upgrade_protos.TierInfo{}
		err = protos.Unmarshal(val.Value, unmarshaledTier)
		if err != nil {
			glog.Errorf("Error while unmarshalling tier %s: %s", tier, err)
			return ret, status.Errorf(codes.Aborted, "Error while getting tiers")
		}
		retMap[tier] = unmarshaledTier
	}
	return &upgrade_protos.GetTiersResponse{Tiers: retMap}, nil
}

func (srv *UpgradeService) CreateTier(
	context context.Context,
	request *upgrade_protos.CreateTierRequest,
) (*protos.Void, error) {
	ret := &protos.Void{}
	if err := upgrade_protos.ValidateCreateTierReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	// This validation code exists to set the contract for this function
	// Once we expose generation numbers to obsidian, this code will go away.
	// DO NOT COPY for new services, this is not a concurrency-safe check.
	networkID := request.GetNetworkId()
	if srv.doesTierExist(networkID, request.GetTierId()) {
		glog.Errorf("Adding existing tier")
		return ret, status.Errorf(codes.FailedPrecondition, "Can't create existing tier")
	}

	err := srv.putTier(networkID, request.GetTierId(), request.GetTierInfo())
	if err != nil {
		glog.Errorf("Error while creating tier: %s", err)
		return ret, status.Errorf(codes.Unavailable, "Error while creating tier")
	}
	return ret, nil
}

func (srv *UpgradeService) UpdateTier(
	context context.Context,
	request *upgrade_protos.UpdateTierRequest,
) (*protos.Void, error) {
	ret := &protos.Void{}
	if err := upgrade_protos.ValidateUpdateTierReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	// This validation code exists to set the contract for this function
	// Once we expose generation numbers to obsidian, this code will go away.
	// DO NOT COPY for new services, this is not a concurrency-safe check.
	networkID := request.GetNetworkId()
	if !srv.doesTierExist(networkID, request.GetTierId()) {
		glog.Errorf("Updating nonexistent tier")
		return ret, status.Errorf(codes.FailedPrecondition, "Can't update tier that doesn't exist")
	}

	err := srv.putTier(networkID, request.GetTierId(), request.GetUpdatedTier())
	if err != nil {
		glog.Errorf("Error while updating tier: %s", err)
		return ret, status.Errorf(codes.Unavailable, "Error while updating tiers")
	}
	return ret, nil
}

func (srv *UpgradeService) DeleteTier(
	context context.Context,
	request *upgrade_protos.DeleteTierRequest,
) (*protos.Void, error) {
	ret := &protos.Void{}
	if err := upgrade_protos.ValidateDeleteTierReq(request); err != nil {
		return ret, protos.NewGrpcValidationError(err)
	}

	// This validation code exists to set the contract for this function
	// Once we expose generation numbers to obsidian, this code will go away.
	// DO NOT COPY for new services, this is not a concurrency-safe check.
	networkID := request.GetNetworkId()
	if !srv.doesTierExist(networkID, request.GetTierIdToDelete()) {
		glog.Errorf("Deleting nonexistent tier")
		return ret, status.Errorf(codes.FailedPrecondition, "Can't delete tier that doesn't exist")
	}

	err := srv.store.Delete(getTierTableName(networkID), request.GetTierIdToDelete())
	if err != nil {
		glog.Errorf("Error while deleting tier: %s", err)
		return ret, status.Errorf(codes.Unavailable, "Error while deleting tier")
	}
	return ret, nil
}

func (srv *UpgradeService) doesTierExist(networkID string, tierName string) bool {
	_, _, err := srv.store.Get(getTierTableName(networkID), tierName)
	return err == nil
}

func getTierTableName(networkID string) string {
	return datastore.GetTableName(networkID, TierTableName)
}

func (srv *UpgradeService) loadTiers(networkId string, tierFilter []string) ([]string, error) {
	if tierFilter != nil && len(tierFilter) > 0 {
		return tierFilter, nil
	} else {
		tiers, err := srv.store.ListKeys(getTierTableName(networkId))
		if err != nil {
			return []string{}, err
		}
		return tiers, nil
	}
}

func (srv *UpgradeService) putTier(networkID string, tierName string, tierInfo *upgrade_protos.TierInfo) error {
	marshalledTier, err := protos.MarshalIntern(tierInfo)
	if err != nil {
		return err
	}
	return srv.store.Put(getTierTableName(networkID), tierName, marshalledTier)
}
